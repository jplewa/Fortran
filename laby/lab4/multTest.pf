module multTest
    
    use mult
    use pfunit_mod
    
    implicit none

contains

    @Test 
    subroutine mult1Test1()

        real :: m1(2,5), m2(2,8), result(2,8)
        integer :: error
        
        m1 = 1.d0
        m2 = 0.d0
        
        call mult1(m1, m2, result, error)
        
        @assertEqual(error, 1)

    end subroutine

    @Test
    subroutine mult1Test2()
    
        real :: m1(2,5), m2(5,2), result(4,4)
        integer :: error
    
        m1 = 1.d0
        m2 = 0.d0
    
        call mult1(m1, m2, result, error)
    
        @assertEqual(error, 2)

    end subroutine

    @Test
    subroutine mult1Test3()

        real :: m1(2,2), m2(2,2), result(2,2), correct(2,2)
        integer :: error
        
        m1(1,:) = [1,3]
        m1(2,:) = [2,4]
        m2(1,:) = [2,1]
        m2(2,:) = [0,2]
        correct(1,:) = [4,10]
        correct(2,:) = [4,8]
        
        call mult1(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(correct, result)

    end subroutine
    
    @Test
    subroutine mult2Test1()
        
        real :: m1(2,5), m2(2,8), result(2,8)
        integer :: error
        
        m1 = 1.d0
        m2 = 0.d0
        
        call mult2(m1, m2, result, error)
        
        @assertEqual(error, 1)

    end subroutine

    @Test
    subroutine mult2Test2()
        
        real :: m1(2,5), m2(5,2), result(4,4)
        integer :: error
        
        m1 = 1.d0
        m2 = 0.d0
        
        call mult2(m1, m2, result, error)
        
        @assertEqual(error, 2)

    end subroutine

    @Test
    subroutine mult2Test3()
        
        real :: m1(2,2), m2(2,2), result(2,2), correct(2,2)
        integer :: error
        
        m1(1,:) = [1,3]
        m1(2,:) = [2,4]
        m2(1,:) = [2,1]
        m2(2,:) = [0,2]
        correct(1,:) = [4,10]
        correct(2,:) = [4,8]
        
        call mult2(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(correct, result)

    end subroutine

    @Test
    subroutine mult3Test1()
        
        real :: m1(2,5), m2(2,8), result(2,8)
        integer :: error
        
        m1 = 1.d0
        m2 = 0.d0
        
        call mult3(m1, m2, result, error)
        
        @assertEqual(error, 1)

    end subroutine

    @Test
    subroutine mult3Test2()
        
        real :: m1(2,5), m2(5,2), result(4,4)
        integer :: error
        
        m1 = 1.d0
        m2 = 0.d0
        
        call mult3(m1, m2, result, error)

        @assertEqual(error, 2)

    end subroutine

    @Test
    subroutine mult3Test3()
        
        real :: m1(2,2), m2(2,2), result(2,2), correct(2,2)
        integer :: error
        
        m1(1,:) = [1,3]
        m1(2,:) = [2,4]
        m2(1,:) = [2,1]
        m2(2,:) = [0,2]
        correct(1,:) = [4,10]
        correct(2,:) = [4,8]
        
        call mult3(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(correct, result)

    end subroutine

    @Test
    subroutine mult4Test1()
        
        real :: m1(2,5), m2(2,8), result(2,8)
        integer :: error
        
        m1 = 1.d0
        m2 = 0.d0
        
        call mult4(m1, m2, result, error)
        
        @assertEqual(error, 1)

    end subroutine

    @Test
    subroutine mult4Test2()
        
        real :: m1(2,5), m2(5,2), result(4,4)
        integer :: error
        
        m1 = 1.d0
        m2 = 0.d0
        
        call mult4(m1, m2, result, error)
        
        @assertEqual(error, 2)

    end subroutine

    @Test
    subroutine mult4Test3()
        
        real :: m1(2,2), m2(2,2), result(2,2), correct(2,2)
        integer :: error
        
        m1(1,:) = [1,3]
        m1(2,:) = [2,4]
        m2(1,:) = [2,1]
        m2(2,:) = [0,2]
        correct(1,:) = [4,10]
        correct(2,:) = [4,8]
        
        call mult4(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(correct, result)

    end subroutine

    @Test
    subroutine mult1234Test1()
        
        real :: m1(500, 1000), m2(1000, 500)
        real :: r1(1000, 1000), r2(1000, 1000), r3(1000, 1000), r4(1000, 1000)
        integer :: error
        
        call RANDOM_NUMBER(m1)
        call RANDOM_NUMBER(m2)

        m1 = m1*1000
        m2 = m2*1000

        call mult1(m1, m2, r1, error)
        call mult2(m1, m2, r2, error)
        call mult3(m1, m2, r3, error)
        call mult4(m1, m2, r4, error)


        @assertEqual(r1, r2)
        @assertEqual(r2, r3)
        @assertEqual(r3, r4)

    end subroutine

end module