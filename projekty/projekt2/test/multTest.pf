module multTest
    
    use mult
    use pfunit_mod
    
    implicit none

contains

    ! dwie macierze 1x1
    @Test 
    subroutine mm1_1x1_test()

        real (kind = 8) :: m1(1,1), m2(1,1), result(1,1), correct(1,1)
        integer (kind = 4) :: error
        
        m1 = 1.d0
        m2 = 3.d0
        correct = 3.d0

        call mm1(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)

    end subroutine

    !macierze 1 × N oraz N × 1 (obie kombinacje
    @Test 
    subroutine mm1_Nx1_1xN_test()
        real (kind = 8) :: m1(1,100), m2(100,1), result(100,100), correct(100,100)
        integer (kind = 4) :: error

        m1 = 1.d0
        m2 = 3.d0
        correct = 3.d0

        call mm1(m1, m2, result, error)

        @assertEqual(error, 0)
        @assertEqual(result, correct)
    end subroutine
    
    @Test 
    subroutine mm1_1xN_Nx1_test()

        real (kind = 8) :: m1(100,1), m2(1,100), result(1,1), correct(1,1)
        integer (kind = 4) :: error
        
        m1 = 1.d0
        m2 = 3.d0
        correct = 3.d0 * 100

        call mm1(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)

    end subroutine

    ! macierze bardzo duże
    @Test 
    subroutine mm1_large1_test()

        real (kind = 8) :: m1(750,1000), m2(500,750), result(500,1000), correct(500,1000)
        integer (kind = 4) :: error
        
        m1 = 1.d0
        m2 = 3.d0
        correct = 3.d0*750

        call mm1(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)

    end subroutine

    @Test 
    subroutine mm1_large2_test()

        real (kind = 8) :: m1(450, 2000), m2(500, 450), result(500, 2000), correct(500, 2000)
        integer (kind = 4) :: error
        
        m1 = 1.d0
        m2 = 3.d0
        correct = 3.d0*450

        call mm1(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)

    end subroutine

    ! macierze, których rozmiary matematycznie nie pozwalają na poprawne pomnożenie
    @Test 
    subroutine mm1_incorrect1_test()

        real (kind = 8) :: m1(2000,750), m2(500,750), result(500,750), correct(500,750)
        integer (kind = 4) :: error
        
        m1 = 1.d0
        m2 = 3.d0
        correct = 0

        call mm1(m1, m2, result, error)
        
        @assertEqual(error, 1)
        @assertEqual(result, correct)

    end subroutine

    @Test 
    subroutine mm1_incorrect2_test()

        real (kind = 8) :: m1(100,50), m2(50,100), result(100,50), correct(100,50)
        integer (kind = 4) :: error
        
        m1 = 1.d0
        m2 = 3.d0
        correct = 0

        call mm1(m1, m2, result, error)
        
        @assertEqual(error, 2)
        @assertEqual(result, correct)

    end subroutine

    ! przypadek “standardowy” z macierzami prostokątnymi małych rozmiarów
    @Test 
    subroutine mm1_standard1_test()

        real (kind = 8) :: m1(2,2), m2(2,2), result(2,2), correct(2,2)
        integer (kind = 4) :: error
        
        m1(1,:) = [1,3]
        m1(2,:) = [2,4]
        m2(1,:) = [2,1]
        m2(2,:) = [0,2]
        correct(1,:) = [4,10]
        correct(2,:) = [4,8]

        call mm1(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)

    end subroutine

    @Test 
    subroutine mm1_standard2_test()

        real (kind = 8) :: m1(3,2), m2(2,3), result(2,2), correct(2,2)
        integer (kind = 4) :: error
        
        m1(1,:) = [1,-1]
        m1(2,:) = [0,3]
        m1(3,:) = [2,1]
        m2(1,:) = [3,2,1]
        m2(2,:) = [1,1,0]
        correct(1,:) = [5,4]
        correct(2,:) = [1,2]

        call mm1(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)

    end subroutine
    
    @Test
    subroutine mm1_standard3_test()

        real (kind = 8) :: m1(3,4), m2(2,3), result(2,4), correct(2,4)
        integer (kind = 4) :: error
        
        m1(1,:) = [1,-1,0,0]
        m1(2,:) = [2,2,1,4]
        m1(3,:) = [3,3,3,5]
        m2(1,:) = [4,1,-2]
        m2(2,:) = [0,2,3]
        correct(1,:) = [0,-8,-5,-6]
        correct(2,:) = [13,13,11,23]

        call mm1(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)

    end subroutine

    @Test
    subroutine mm1_standard4_test()

        real (kind = 8) :: m1(3,1), m2(4,3), result(4,1), correct(4,1)
        integer (kind = 4) :: error
        
        m1(:,1) = [3,4,2]
        m2(1,:) = [13,8,6]
        m2(2,:) = [9,7,4]
        m2(3,:) = [7,4,0]
        m2(4,:) = [15,6,3]
        correct(:,1) = [83,63,37,75]

        call mm1(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)

    end subroutine

    ! dwie macierze 1x1
    @Test 
    subroutine mm2_1x1_test()
         
        real (kind = 8) :: m1(1,1), m2(1,1), result(1,1), correct(1,1)
        integer (kind = 4) :: error
        
        m1 = 1.d0
        m2 = 3.d0
        correct = 3.d0
        
        call mm2(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)
        
    end subroutine
    
    !macierze 1 × N oraz N × 1 (obie kombinacje
    @Test 
    subroutine mm2_Nx1_1xN_test()
    
        real (kind = 8) :: m1(1,100), m2(100,1), result(100,100), correct(100,100)
        integer (kind = 4) :: error
        m1 = 1.d0
        m2 = 3.d0
        correct = 3.d0
         
        call mm2(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)

    end subroutine
    
    @Test 
    subroutine mm2_1xN_Nx1_test()
         
        real (kind = 8) :: m1(100,1), m2(1,100), result(1,1), correct(1,1)
        integer (kind = 4) :: error
        
        m1 = 1.d0
        m2 = 3.d0
        correct = 3.d0 * 100
        
        call mm2(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)
     
    end subroutine
    
    ! macierze bardzo duże
    @Test 
    subroutine mm2_large1_test()
    
        real (kind = 8) :: m1(750,1000), m2(500,750), result(500,1000), correct(500,1000)
        integer (kind = 4) :: error
        
        m1 = 1.d0
        m2 = 3.d0
        correct = 3.d0*750
    
        call mm2(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)
    
    end subroutine

    @Test 
    subroutine mm2_large2_test()
    
        real (kind = 8) :: m1(450, 2000), m2(500, 450), result(500, 2000), correct(500, 2000)
        integer (kind = 4) :: error
        
        m1 = 1.d0
        m2 = 3.d0
        correct = 3.d0*450
    
        call mm2(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)
    
    end subroutine
    
    ! macierze, których rozmiary matematycznie nie pozwalają na poprawne pomnożenie
    @Test 
    subroutine mm2_incorrect1_test()
    
        real (kind = 8) :: m1(2000,750), m2(500,750), result(500,750), correct(500,750)
        integer (kind = 4) :: error
        
        m1 = 1.d0
        m2 = 3.d0
        correct = 0
    
        call mm2(m1, m2, result, error)
        
        @assertEqual(error, 1)
        @assertEqual(result, correct)
    
    end subroutine
     
    @Test 
    subroutine mm2_incorrect2_test()
     
        real (kind = 8) :: m1(100,50), m2(50,100), result(100,50), correct(100,50)
        integer (kind = 4) :: error
        
        m1 = 1.d0
        m2 = 3.d0
        correct = 0
    
        call mm2(m1, m2, result, error)
        
        @assertEqual(error, 2)
        @assertEqual(result, correct)

    end subroutine
    
    ! przypadek “standardowy” z macierzami prostokątnymi małych rozmiarów
    @Test 
    subroutine mm2_standard1_test()
    
        real (kind = 8) :: m1(2,2), m2(2,2), result(2,2), correct(2,2)
        integer (kind = 4) :: error
        
        m1(1,:) = [1,3]
        m1(2,:) = [2,4]
        m2(1,:) = [2,1]
        m2(2,:) = [0,2]
        correct(1,:) = [4,10]
        correct(2,:) = [4,8]
    
        call mm2(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)
    
    end subroutine
    
    @Test 
    subroutine mm2_standard2_test()
        
        real (kind = 8) :: m1(3,2), m2(2,3), result(2,2), correct(2,2)
        integer (kind = 4) :: error
        
        m1(1,:) = [1,-1]
        m1(2,:) = [0,3]
        m1(3,:) = [2,1]
        m2(1,:) = [3,2,1]
        m2(2,:) = [1,1,0]
        correct(1,:) = [5,4]
        correct(2,:) = [1,2]
        
        call mm2(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)

     end subroutine
    
    @Test
    subroutine mm2_standard3_test()
        
        real (kind = 8) :: m1(3,4), m2(2,3), result(2,4), correct(2,4)
        integer (kind = 4) :: error
        
        m1(1,:) = [1,-1,0,0]
        m1(2,:) = [2,2,1,4]
        m1(3,:) = [3,3,3,5]
        m2(1,:) = [4,1,-2]
        m2(2,:) = [0,2,3]
        correct(1,:) = [0,-8,-5,-6]
        correct(2,:) = [13,13,11,23]
        
        call mm2(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)

    end subroutine

    @Test
    subroutine mm2_standard4_test()
        
        real (kind = 8) :: m1(3,1), m2(4,3), result(4,1), correct(4,1)
        integer (kind = 4) :: error
        
        m1(:,1) = [3,4,2]
        m2(1,:) = [13,8,6]
        m2(2,:) = [9,7,4]
        m2(3,:) = [7,4,0]
        m2(4,:) = [15,6,3]
        correct(:,1) = [83,63,37,75]
        
        call mm2(m1, m2, result, error)
        
        @assertEqual(error, 0)
        @assertEqual(result, correct)

    end subroutine

end module